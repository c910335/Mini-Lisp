class Lisp

rule

   main : # Toku ni nashi.
        | main param { result = val[1].call; puts result if $interaction }

   exp : '(' param params ')' { result = Exp.new val[1], val[2] }

   params : params param { result = val[0] << val[1] }
          |              { result = [] }

   param : '(' FUNC '(' params ')' param ')' { result = func_new val[3], val[5] }
         | exp
         | NUMBER
         | BOOL
         | ID                                { result = Identifier.new val[0] }

end

---- header ----

require './lisp.rex'

class Exp
   def initialize func, params
      @func, @params = func, params
   end

   def value
      call
   end

   def call
      @func.call @params
   end
end

class Identifier

   attr_reader :name

   def initialize name
      @name = name
   end

   def value
      $variables[@name].value
   end

   def call p = nil
      if p.nil?
         value.call
      else
         value.call p
      end
   end
end

module SelfValue
   def value
      self
   end
end

class Fixnum include SelfValue end
class TrueClass include SelfValue end
class FalseClass include SelfValue end
class Proc include SelfValue end

def func_new params, exp
   lambda do |p|
      values = []
      p.each do |ap|
         values << ap.value
      end
      stack = []
      params.each_index do |i|
         stack << $variables[params[i].name]
         $variables[params[i].name] = values[i]
      end
      r = exp.call
      params.each do |id|
         $variables[id.name] = stack.shift
      end
      r
   end
end

$variables = {
   '+' => ->(p) { s = 0; p.each { |n| s += n.value }; s },
   '-' => ->(p) { p[0].value - p[1].value },
   '*' => ->(p) { s = 1; p.each { |n| s *= n.value }; s },
   '/' => ->(p) { p[0].value / p[1].value },
   'mod' => ->(p) { p[0].value % p[1].value },
   '>' => ->(p) { p[0].value > p[1].value },
   '<' => ->(p) { p[0].value < p[1].value },
   '=' => ->(p) { p[0].value == p[1].value },
   'and' => ->(p) { p[0].value && p[1].value },
   'or' => ->(p) { p[0].value || p[1].value },
   'not' => ->(p) { !p[0].value },
   'print-num' => lambda { |p|
      num = p.first.value.to_i
      puts num
      num
   },
   'print-bool' => lambda { |p|
      bool = p.first.value ? '#t' : '#f'
      puts bool
      bool
   },
   'if' => ->(p) { if p[0].value then p[1].value else p[2].value end },
   'define' => ->(p) { $variables[p[0].name] = p[1].value }
}
$interaction = true

---- inner ----

   def interpret source
      begin
         if source == :stdin
            scan_str gets
         else
            scan_file source
         end
      rescue ParseError, NoMemoryError
         puts 'Syntax Error'
      rescue TypeError
         puts 'Type Error'
      rescue
         puts 'Syntax Error'
      end
   end

---- footer ----

filename = ARGV[0]
lisp = Lisp.new

if filename.nil?
   loop do
      print '> '
      lisp.interpret :stdin
   end
else
   $interaction = false
   lisp.interpret filename
end
